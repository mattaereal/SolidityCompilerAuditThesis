\section{Prólogo}
Considerando que el mundo de la tecnología informática es un campo relativamente nuevo, que día a día crece exponencialmente, hay que destacar que dentro de él también se encuentran campos como el de la \textit{seguridad informática}, que son mucho más recientes.\\

La explotación de vulnerabilidades existentes y nuevas permite el acceso no autorizado a los bienes de una empresa, siendo un problema de seguridad de alta gravedad. \textit{Una gran proporción de todos los incidentes de seguridad de software son causados por atacantes que explotan vulnerabilidades conocidas.}\cite{sectesting}

\begin{displayquote}
\textit{``Romper algo es más fácil que diseñar algo que no se puede romper."}
\newline{\null\hfill -- Gary McGraw}
\end{displayquote}

Por eso es fundamental que se realice la comprobación de las aplicaciones, redes, sistemas nuevos y ya presentes, en búsqueda de vulnerabilidades para asegurarse que nadie sin acceso autorizado haya accedido previamente ni lo haga en el futuro.\\

Los análisis de seguridad comúnmente no llegan a cubrir el total de la infraestructura de una empresa. Hay dos principales razones por las cuales esto sucede: la inmensidad de las mismas y los plazos breves de tiempo disponibles para el trabajo\cite{krypsys}\cite{specopssoft}\cite{crest}\cite{notsosecure}. No obstante, los mecanismos utilizados son efectivos, lo suficiente como para identificar vulnerabilidades conocidas, y comprobar cómo un atacante podría acceder a sus sistemas.\\

Las técnicas de testeo empleadas en el ciclo de vida del desarrollo seguro de un software se pueden distinguir en cuatro categorías: \textbf{(1)} \textit{pruebas de seguridad basadas en modelos que se basan en los requisitos y los modelos de diseño creados durante la fase de análisis y diseño}, \textbf{(2)} \textit{pruebas basadas en código y análisis estático en el código fuente y bytecode creado durante el desarrollo}, \textbf{(3)} \textit{pruebas de penetración y análisis dinámico en sistemas en ejecución, ya sea en un entorno de prueba o producción}, así como \textbf{(4)} \textit{pruebas de regresión de seguridad realizadas durante el mantenimiento}\cite{sectesting}. A pesar de que algunos mecanismos eran utilizados específicamente en el mundo de la seguridad informática, \textit{dejando de lado la revisión de código por supuesto}, desarrolladores y DevOps están utilizando cada vez más estrategias como \textit{fuzzing y análisis estático de código} para probar la calidad de su software\cite{accelerate_report}\cite{concepts}.

\section{Motivación}
En las carreras universitarias las cuestiones de seguridad no se tratan con profundidad y de una manera enfocada al problema, sino desde los aspectos subyacentes que permiten entender los problemas de seguridad y sus posibles soluciones.  Es por ello que los graduados que decidan dedicarse a la seguridad informática, deben especializarse por su cuenta a través de cursos, o mediante el aprendizaje profesional que se da a través de la resolución de problemáticas de los clientes.\\

Esta propuesta surge por un interés personal originado gracias a las materias \textit{Lenguajes de Programación y Diseño de Compiladores}, y al incremento que ha habido últimamente en desarrollo de nuevos lenguajes, que poseen propósitos y contextos distintos\cite{Klabnik:2018:RPL:3271463}\cite{Forsgren:2018:ASL:3235404}.

\subsection{Contexto}
Los \textit{Smart Contracts}, son programas que poseen una ejecución completamente verificable y observable. Esto permite que exista la certeza de que la ejecución del mismo no pueda ser alterada, abriendo una nueva posibilidad de casos de usos que en las plataformas de cómputo tradicionales no existían.\\

\textit{Ethereum Network} fue desarrollada para ser una plataforma de \texttt{smart contracts}, siendo la primera que posee un lenguaje (del estilo bytecode) con característica \textit{Turing complete} (permite que un el lenguaje pueda llegar a programarse para realizar cualquier tipo de operación) que corre en una máquina virtual llamada \textit{Ethereum Virtual Machine (EVM)}.\\

Si bien hay diversos lenguajes de programación que son compilados a la representación en bytecode para EVM, el que es oficialmente desarrollado y posee financiación por parte de la \textit{Ethereum Foundation} es \textbf{Solidity}\cite{solidity_readthedocs}.\\

\texttt{Solidity}, que si bien se puede percibir como un lenguaje medianamente similar a \texttt{Javascript} en cuanto a sus aspectos sintácticos y en menor medida semánticos, nació de la necesidad de tener un lenguaje de alto nivel orientado a desarrollar \textit{Smart Contracts} que permita interactuar con la \texttt{Ethereum Network}. \\

Los \texttt{smart contracts} hoy en día manipulan y almacenan caudales de dinero de gran magnitud, es por eso que es inevitable que la seguridad en estos casos se haga presente.\\

Ha habido ya muchos casos registrados de pérdidas de miles de millones de dólares, debido a descuidos a la hora de desarrollar y por no entender este muy reciente \textit{“paradigma”}:
\begin{itemize}
\item Uno de los clientes más populares utilizado para facilitar a los usuarios la interacción con la red, congeló fondos valuados en \$100 millones de dólares debido a un error en su código\cite{Hertig:Alyssa:Coindesk}.
\item En julio del 2017, días después de que un hacker obtuviera más de 7 millones de dólares explotando una vulnerabilidad, debido a otro error en el mismo cliente, otro hacker obtuvo acceso a fondos de algunas cuentas, valuado en un total de \$37 millones de dólares \cite{Pearson:Jordan:Motherboard}.
\item Un ejemplo de un error de diseño del lenguaje con impacto a gran escala es el caso del famoso llamado, en este ambiente, \texttt{reentrancy bug}. Permitía a un atacante retirar una gran cantidad de veces su balance de un contrato, volviendo a llamar a la misma funcionalidad en medio de su ejecución, logrando así multiplicar sus fondos\cite{Vessenes:Peter:Vessenes}.
\end{itemize}
\bigskip

Así es como que desde el lado de los estudios de los lenguajes de programación, parece de suma relevancia poseer lenguajes y compiladores correspondientes que funcionen de manera esperada, sin permitirle a los desarrolladores la posibilidad de cometer errores catastróficos.\\

En este contexto un error en la generación del bytecode podría detener el funcionamiento de una red de miles de máquinas virtuales, o financieramente impactar de formas inesperadas en el contrato desarrollado.

\section{Objetivos}
\textit{Realizar una investigación de las estrategias y metodologías existentes para auditar compiladores, brindando primero una introducción a la auditoría de software, luego una introducción a auditoría específicamente de compiladores, comentando las técnicas más populares.}\\

\textit{Finalmente evaluar como caso de uso una auditoría al lenguaje \textbf{Solidity} y a su compilador \textbf{solc}, explicando el proceso y herramientas utilizadas, mostrando los resultados obtenidos.}
